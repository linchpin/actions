name: Deploy to WP Engine

on:
  workflow_call:
    inputs:
      install_name:
        description: 'The name of the install on WP Engine we are deploying to'
        required: true
        type: string
      site_url:
        description: 'The site url we are deploying to (full url)'
        required: true
        type: string
      environment:
        description: 'The environment we are deploying to (production, staging, dev)'
        required: false
        default: 'staging'
        type: string
      branch:
        description: 'The branch we are deploying to'
        required: false
        default: 'staging'
        type: string
      deployment:
        description: 'The deployment ID from previous jobs'
        required: true
        type: string
      deployment_path:
        description: 'Provide if the deployment path is non standard'
        required: false
        default: '_wpeprivate/releases'
        type: string
      workflow_run_id:
        description: 'Workflow Run ID to get artifacts from'
        required: true
        type: string
      remote_plugin_install:
        description: 'Remotely install plugins instead of using composer'
        required: false
        default: false
        type: boolean
    secrets:
      deployment_ssh_key:
        description: 'WP Engine SSH Key needed for deployment'
        required: true
      gh_bot_token:
        description: 'Bot Access to Private repo'
        required: true

jobs:
  deploy:
    name: To WP Engine
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
      url: ${{ inputs.site_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Get Current Version
        id: version
        run: echo "current=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Get branch name
        id: branch
        uses: tj-actions/branch-names@v7
    
      - name: Deployment In Progress
        id: in_progress_deployment
        uses: octokit/request-action@v2.x
        with:
          route: POST /repos/{repo}/deployments/{deployment}/statuses
          repo: ${{ github.repository }}
          deployment: ${{ inputs.deployment }}
          environment: ${{ inputs.environment }}
          environment_url: ${{ inputs.site_url }}
          log_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          state: in_progress
          mediaType: '{"previews": ["flash", "ant-man"]}'
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: Download All Artifacts
        uses: actions/download-artifact@v3
        id: download
        with:
          name: 'release'
          path: ./

      - name: Generate release zip
        id: folder
        run: |
          echo "folder=$(date +'%s')" >> $GITHUB_OUTPUT  

      - name: Configure SSH Connection with WP Engine
        uses: linchpin/actions-wpengine-ssh@main
        with:
          ssh_user: ${{ inputs.install_name }}
          ssh_key: ${{ secrets.deployment_ssh_key }}
          ssh_host: "${{ inputs.install_name }}.ssh.wpengine.net"

      - name: Upload Assets
        id: upload_assets
        run: |
          mv ./release.zip ./${{ steps.folder.outputs.folder }}.zip
          ssh wpengine "mkdir -p ~/sites/${{ inputs.install_name }}/${{ inputs.deployment_path }}"
          rsync -e "ssh -p 22" -W --progress "${{ steps.folder.outputs.folder }}.zip" wpengine:~/sites/"${{ inputs.install_name }}"/"${{ inputs.deployment_path }}"

      - name: Unzip Assets
        id: unzip_assets
        run: |
          ssh wpengine "unzip -o -q ~/sites/${{ inputs.install_name }}/${{ inputs.deployment_path }}/${{ steps.folder.outputs.folder }}.zip -d ~/sites/${{ inputs.install_name }}/${{ inputs.deployment_path }}"

      - name: Execute Commands On Server
        id: execute_bash
        run: |
          ssh wpengine "mkdir -p ~/sites/${{ inputs.install_name }}/${{ inputs.deployment_path }}/release/.deployment/"
          ssh wpengine "cd ~/sites/${{ inputs.install_name }}/${{ inputs.deployment_path }}/release/.deployment/ && wget -O entrypoint.sh https://raw.githubusercontent.com/linchpin/actions/main/.deployment/wpengine-entrypoint.sh && chmod +x ./entrypoint.sh && bash ./entrypoint.sh"


  # Loop through all themes passed from inputs.themes
  plugin_install:
    name: WordPress Plugin Install(s)
    runs-on: ubuntu-latest
    needs: deploy
    steps:

      # When installing the plugins we only need the lock file
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          path: 'build'
          sparse-checkout: |
            composer.lock
          sparse-checkout-cone-mode: false

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'

      - name: Configure SSH Connection with WP Engine
        uses: linchpin/actions-wpengine-ssh@main
        with:
          ssh_user: ${{ inputs.install_name }}
          ssh_key: ${{ secrets.deployment_ssh_key }}
          ssh_host: "${{ inputs.install_name }}.ssh.wpengine.net"

      - name: Get WordPress plugins and themes for install
        if: ${{ inputs.remote_plugin_install != false }}
        id: parse_composer_lock
        shell: bash
        run: |
          # Read the composer.lock file and loop through each package
          total_plugins=$(jq '.packages | length' ./build/composer.lock)
          install_path="/home/wpe-user/sites/${{ inputs.install_name }}"

          echo "::notice::Potentially Installing or Updating $total_plugins Plugins,Packages or Themes"

          ssh_wpengine_wp() {
            # Use local variables to store the function arguments
            local type=$1 # plugin or theme
            local wp_command=$2
            local slug=$3
            local version=$4

            local path="--path=$install_path"

            # Construct the full command based on whether wp_command is "is-installed" or version is blank
            local full_command
            if [[ $wp_command == "is-installed" || -z $version ]]; then
                full_command="wp $type $wp_command $slug $path"
            else
                full_command="wp $type $wp_command $slug --version=$version $path"
            fi

            echo "::notice::Calling: $full_command"

            # Execute the command and return the result
            ssh wpengine "$full_command"
            local exit_code=$?

            if [[ $wp_command == "is-installed" ]]; then
              if [[ $exit_code == 0 ]]; then
                echo "yes"
              else
                echo "no"
              fi
            else
              echo $exit_code
            fi
          }

          while read -r package; do

            echo "::notice::Installing or Updating $package"

            # Extract the name, type, and version from the package
            name=$(echo "$package" | jq -r '.name')
            type=$(echo "$package" | jq -r '.type')
            version=$(echo "$package" | jq -r '.version')

            echo "::notice::Installing or Updating $name $type $version"

            # Check if the type is wordpress-plugin or wordpress-theme
            if [[ "$type" == "wordpress-plugin" || "$type" == "wordpress-theme" ]]; then
              # Get the slug by splitting the name at the /
              slug=${name#*/}

              # Parse the command type based on the package type in composer.lock
              theme_or_plugin=${type#wordpress-}
  
              echo "Checking if $slug is installed"
              # Check if the plugin or theme is installed using WP-CLI
              installed=$(ssh_wpengine_wp "$theme_or_plugin is-installed $slug")
              echo "Installed: $installed"
  
              # Install or update the plugin or theme based on the check
              if [[ "$installed" == "no" ]]; then
                echo "Try To install $slug at version $version"
                installed_plugin=$(ssh_wpengine_wp "$wp_command install $slug $version")
              else
                # Get the current version using WP-CLI
                echo "Fetching current version for $slug"
                current_version=$(ssh wpengine "wp $wp_command get $slug --field=version --path=$install_path")
                
                echo "Comparing versions: $current_version vs $version"
                # Check if the comparison_result is 0, meaning the current version is less than the required version

                comparison_result=$(php -r "echo version_compare('$current_version', '$version');")
                echo "Comparison Result: $comparison_result"

                if [[ "$comparison_result" == "-1" ]]; then
                  echo "Update $slug to $version"
                  updated_plugin=$(ssh_wpengine_wp "$wp_command update $slug $version")
                else
                  echo "Versions are equal or your. No update required for $slug."
                fi
              fi
            else
              echo "Skipping $name because it is not a WordPress plugin or theme."
            fi
          done < <(jq -c '.packages[]' ./build/composer.lock)


  status:
    name: Deploy Status
    runs-on: ubuntu-latest
    needs: [deploy, plugin_install]
    steps:
      - name: Configure SSH Connection with WP Engine
        uses: linchpin/actions-wpengine-ssh@main
        with:
          ssh_user: ${{ inputs.install_name }}
          ssh_key: ${{ secrets.deployment_ssh_key }}
          ssh_host: "${{ inputs.install_name }}.ssh.wpengine.net"

      - name: Cleanup Maintenance
        id: cleanup_maintenance
        run: |
          ssh wpengine "cd ~/sites/${{ inputs.install_name }}/${{ inputs.deployment_path }}/release/.deployment/ && wget -O endpoint.sh https://raw.githubusercontent.com/linchpin/actions/feature/maybe-skip-composer/.deployment/wpengine-endpoint.sh && chmod +x ./endpoint.sh && bash ./endpoint.sh"
    
    # - name: Clear Page and Object Cache
      # if: ${{ always() && 'production' == inputs.environment }}
      # run: |
        # ssh wpengine "cd ~/sites/${{ inputs.install_name }} && wp cache flush && wp page-cache flush"

      - name: Set Deployment Status as Successful
        if: ${{ success() }}
        uses: octokit/request-action@v2.x
        with:
          route: POST /repos/{repo}/deployments/{deployment}/statuses
          repo: ${{ github.repository }}
          deployment: ${{ inputs.deployment }}
          environment: ${{ inputs.environment }}
          environment_url: ${{ inputs.site_url }}
          log_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          state: success
          mediaType: '{"previews": ["flash", "ant-man"]}'
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: Set Deployment Status as Failboat
        if: ${{ failure() }}
        uses: octokit/request-action@v2.x
        with:
          route: POST /repos/{repo}/deployments/{deployment}/statuses
          repo: ${{ github.repository }}
          deployment: ${{ inputs.deployment }}
          environment: ${{ inputs.environment }}
          environment_url: ${{ inputs.site_url }}
          log_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          state: failure
          mediaType: '{"previews": ["flash", "ant-man"]}'
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
